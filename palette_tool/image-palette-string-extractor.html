<!DOCTYPE html>
<html lang="en">
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 20px;
      color: #333;
    }

    h1 {
      text-align: center;
      color: #2c3e50;
    }

    h2 {
      color: #3498db;
      margin-bottom: 10px;
    }

    button {
      padding: 10px 20px;
      background-color: #2ecc71;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin: 10px 0;
    }

    button:hover {
      background-color: #27ae60;
    }

    #uploadContainer {
      margin: 20px 0;
    }

    label {
      display: block;
      margin-top: 20px;
    }

    #runButton {
      display: block;
      width: 100%;
      max-width: 250px;
      margin-top: 10px;
    }

    #outputField {
      width: 100%;
      max-width: 700px;
      margin-top: 20px;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-family: monospace;
      white-space: pre-wrap;
    }

    textarea {
      font-family: monospace, "Courier New", monospace;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
    }

    #mapUploadButton,
    #imageUploadButton {
      width: 100%;
      max-width: 250px;
      margin-top: 10px;
    }

    #uploadContainer input[type="file"] {
      display: block;
      margin: 10px 0;
      max-width: 300px;
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    #disableCoordReference {
      margin-top: 10px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
    }

    .input-group {
      margin-bottom: 20px;
    }

    .input-group p {
      font-size: 14px;
      color: #555;
    }

    a {
      color: #3498db;
    }

    a:hover {
      text-decoration: underline;
    }

    button:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }

    .notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #2ecc71;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 16px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.35s ease-in-out;
      z-index: 9999;
    }
  </style>

  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image and Map Color Extractor</title>
  </head>
  <body>
    <h1>SMC Image Palette String Extractor</h1>
    <i style="color: #838383; text-align: center; width: 100%; display: block"
      >By MrGerund (The Flying Dutchman)</i
    ><br />
    This tool is used to generate palette strings for the implementation of
    tilesets, backgrounds, etc. in Super Mario Construct.<br />
    Palette strings in the source code can be found inside of the JSON files
    within <u>"SMC-game/files/Palettes"</u>.<br />
    <h2>Select an upload type</h2>
    <button id="imageUploadButton">Extract from image</button>
    <button id="mapUploadButton">Extract in bulk from folder</button
    ><br /><br />

    <div id="uploadContainer">
      <input
        type="file"
        id="fileInput"
        accept="image/*"
        multiple=""
        style="display: none"
      />
    </div>

    <label for="disableCoordReference">
      <h2>Configure & run</h2>

      The first image is always used as a reference for the coordinates of the
      colours. Making sure ALL images have the same amount of RGB values in
      their part of the string.<br />
      If you don't want this, then you can disable it with the checkbox below
      (not recommended), though you will most likely have to do manual changes
      afterwards. <br />
      Use this if other palettes have MORE colors than the base.
      <br /><input type="checkbox" id="disableCoordReference" /><b
        >Disable coordinate reference</b
      ></label
    ><br /><br />

    <button id="runButton" style="display: block">
      Generate palette string
    </button>
    <div id="output" style="display: none">
      <br /><br />
      <textarea id="outputField" rows="10" cols="80" readonly=""></textarea>
      <br />
      <button onclick="copyToClipboard()">Copy</button>
    </div>

    <script>
      const fileInput = document.getElementById("fileInput");
      const runButton = document.getElementById("runButton");
      const uploadContainer = document.getElementById("uploadContainer");
      const imageUploadButton = document.getElementById("imageUploadButton");
      const mapUploadButton = document.getElementById("mapUploadButton");
      const output = document.getElementById("output");
      let selectedFiles = [];
      let currentTab = "";

      const copyToClipboard = () => {
        const textToCopy = document.getElementById("outputField").value;
        navigator.clipboard.writeText(textToCopy).then(() => {
          showNotification("Copied!");
        });
      };

      const showNotification = (message) => {
        // Create the notification element
        const notification = document.createElement("div");
        notification.className = "notification";
        notification.textContent = message;

        // Append the notification to the body
        document.body.appendChild(notification);

        // Trigger the animation (fade in)
        setTimeout(() => {
          notification.style.opacity = "1";
        }, 100);

        // Hide the notification after 2 seconds
        setTimeout(() => {
          notification.style.opacity = "0";
          // Remove the notification element from the DOM after fading out
          setTimeout(() => {
            notification.remove();
          }, 500);
        }, 2000);
      };

      imageUploadButton.addEventListener("click", () => {
        if (currentTab !== "image") {
          currentTab = "image"; // Update the current tab
          setFileInput("image/*", false);
          fileInput.value = ""; // Clear the visual display of selected files
          imageUploadButton.disabled = true;
          mapUploadButton.disabled = false;
        }
      });

      mapUploadButton.addEventListener("click", () => {
        if (currentTab !== "map") {
          currentTab = "map"; // Update the current tab
          setFileInput("", true);
          fileInput.value = ""; // Clear the visual display of selected files
          imageUploadButton.disabled = false;
          mapUploadButton.disabled = true;
        }
      });

      function setFileInput(acceptType, isFolder) {
        fileInput.style.display = "block";
        fileInput.setAttribute("accept", acceptType);
        if (isFolder) {
          fileInput.setAttribute("webkitdirectory", "");
        } else {
          fileInput.removeAttribute("webkitdirectory");
        }
        runButton.style.display = "block"; // Show the run button after selection mode is chosen
      }

      fileInput.addEventListener("change", (event) => {
        selectedFiles = Array.from(event.target.files);
      });

      runButton.addEventListener("click", () => {
        if (selectedFiles.length === 0) {
          alert("Please select files first.");
          return;
        }
        handleFiles(selectedFiles);
      });

      function handleFiles(files) {
        const disableCoordReference = document.getElementById(
          "disableCoordReference"
        ).checked;
        const outputField = document.getElementById("outputField");
        let outputString = "";
        let referenceCoordinates = [];

        files.forEach((file, fileIndex) => {
          const reader = new FileReader();
          reader.onload = function (e) {
            const img = new Image();
            img.src = e.target.result;

            img.onload = function () {
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");
              canvas.width = img.width;
              canvas.height = img.height;
              ctx.drawImage(img, 0, 0);

              const imageData = ctx.getImageData(
                0,
                0,
                canvas.width,
                canvas.height
              );
              const { data, width, height } = imageData;
              const colorMap = new Map();

              if (
                referenceCoordinates.length > 0 &&
                !disableCoordReference &&
                fileIndex > 0
              ) {
                referenceCoordinates.forEach(({ x, y }) => {
                  const index = (y * width + x) * 4;
                  const r = data[index],
                    g = data[index + 1],
                    b = data[index + 2],
                    a = data[index + 3];

                  if (a === 0) return; // Skip transparent pixels

                  const rgbString = `${r},${g},${b}`;
                  outputString += `${rgbString} | `;
                });
                outputField.value = `"${outputString.slice(0, -3)}"`;
                output.style.display = "block";
                window.scrollTo({
                  top: document.body.scrollHeight,
                  behavior: "smooth",
                });
                return;
              }

              for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                  const index = (y * width + x) * 4;
                  const r = data[index],
                    g = data[index + 1],
                    b = data[index + 2],
                    a = data[index + 3];

                  if (a === 0) continue; // Skip transparent pixels

                  const rgbString = `${r},${g},${b}`;
                  if (!colorMap.has(rgbString)) {
                    colorMap.set(rgbString, { r, g, b });
                    referenceCoordinates.push({ x, y });
                  }
                }
              }

              let key = 1;
              const mapSize = colorMap.size;
              colorMap.forEach((rgb) => {
                const endSymbol = mapSize !== key ? " | " : " -- ";
                outputString += `${rgb.r},${rgb.g},${rgb.b}${endSymbol}`;
                key++;
              });

              if (fileIndex === files.length - 1) {
                outputField.value = outputString.slice(0, -4) + " -- "; // Remove trailing symbols
                output.style.display = "block";
                window.scrollTo({
                  top: document.body.scrollHeight,
                  behavior: "smooth",
                });
              }
            };
          };

          reader.readAsDataURL(file);
        });
      }
    </script>
  </body>
</html>
