<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tile Layout Visualizer</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f4;
        color: #333;
        margin: 0;
        padding: 20px;
      }

      h1 {
        text-align: center;
        color: #2c3e50;
      }

      h2 {
        color: #3498db;
        margin-bottom: 10px;
      }

      input[type="file"],
      input[type="number"] {
        padding: 8px;
        margin: 10px 0;
        width: 100%;
        max-width: 300px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }

      input[type="file"] {
        padding: 5px;
      }

      button {
        padding: 10px 15px;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        width: 100%;
        max-width: 200px;
        margin-top: 20px;
        transition: background-color 0.5s ease, colour 0.5s ease;
      }

      #submit {
        background-color: #2ecc71;
      }
      #submit:hover {
        background-color: #27ae60;
      }
      #reload {
        background-color: #fd4ea8;
      }

      #reload:hover {
        background-color: #ff309b;
      }

      #save {
        background-color: #53cf15;
      }
      #save:hover {
        background-color: #3eb503;
      }
      #load {
        background-color: #3487db;
      }
      #load:hover {
        background-color: #196abb;
      }
      #saveEdited {
        background-color: #ffb618;
      }
      #saveEdited:hover {
        background-color: #e99f00;
      }
      #saveNew {
        background-color: #fc83c1;
      }
      #saveNew:hover {
        background-color: #deaded;
      }

      button:disabled {
        background-color: #bdc3c7 !important;
        cursor: not-allowed;
      }

      canvas {
        display: block;
        margin: 20px auto;
        border: 1px solid #ccc;
        background-color: white;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        transition: transform 0.5s ease-in-out;
        filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.2));
      }

      #canvas:hover {
        transform: scale(2);
        z-index: 999999;
      }

      textarea {
        display: block;
        margin: 20px auto;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 16px;
        width: 95%;
        resize: none;
        height: 400px;
      }

      input[type="text"] {
        display: block;
        margin: 20px auto;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 16px;
        width: 95%;
        resize: none;
      }

      input[type="text"]:focus {
        outline: none !important;
        border-color: none !important;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        background-color: #ffffff;
        padding: 20px;
        margin-bottom: 50px;
        border-radius: 8px;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
      }

      a {
        color: #3498db;
      }

      a:hover {
        text-decoration: underline;
      }

      label {
        display: block;
        margin-top: 10px;
      }

      .input-group {
        margin-bottom: 20px;
      }

      .input-group p {
        margin-bottom: 5px;
        font-size: 14px;
        color: #555;
      }

      .notification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #0882e5;
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        font-size: 16px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.35s ease-in-out;
        z-index: 9999;
      }

      .scroll {
        position: fixed;
        bottom: 20px;
        background-color: #0882e5;
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        font-size: 16px;
        z-index: 9999;
      }

      .scroll:hover {
        cursor: pointer;
      }
    </style>
  </head>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // Check if the user is on a mobile device
      if (/Android|iPhone/i.test(navigator.userAgent)) {
        // Replace the content of the body with a custom message
        document.body.innerHTML =
          "<h1>This tool is designed to only work on desktop devices.</h1>";
      }
    });
  </script>
  <body>
    <div
      class="scroll"
      style="right: 20px"
      onclick="window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });"
    >
      To bottom
    </div>
    <div
      class="scroll"
      style="left: 20px"
      onclick="window.scrollTo({ top: 0, behavior: 'smooth' });"
    >
      To top
    </div>

    <h1>Tile Layout Visualizer</h1>
    <i style="color: #838383; text-align: center; width: 100%; display: block"
      >By MrGerund (The Flying Dutchman)</i
    ><br />
    <div class="container">
      <p>
        This tool is used to visualize the position of tileset components in the
        editor. Start with inputting your files to generate an array for easier
        readability, which can then be used to output a new JSON file.
      </p>

      <h2>Input a JSON</h2>
      <p>
        This can be either <u>files\Tile layouts\TileLayouts_SMAS1.json</u> or
        <u>files\Tile layouts\TileLayouts_SMW.json</u> depending on the
        gamestyle you're adding a tileset for.
      </p>
      <div class="input-group">
        <input
          type="file"
          id="jsonInput"
          accept=".json"
          onchange="document.getElementById(`reload`).disabled = false"
        />
      </div>

      <h2>JSON index</h2>
      <p>
        This is the index of your spritesheet within the JSON file,
        corresponding to the first value for your tileset in
        <u>eventSheets\Toolbar menus\Tilesets menu.json</u>.
      </p>
      <div class="input-group">
        <input type="number" id="indexInput" value="1" />
      </div>

      <h2>Input your primary tilemap</h2>
      <p>
        Spritesheet must be a grid of 16x16 pixels with a height and width
        consisting of multiples of 16. (example: 160 width by 256 height) You
        can find these in the /images/ folder inside of SMC-game. The name can
        be for example tilemap_1_sewer.png for the SMAS sewer tileset.
      </p>
      <div class="input-group">
        <input
          type="file"
          id="spriteInput"
          accept=".png"
          onchange="document.getElementById(`reload`).disabled = false"
        />
      </div>

      <h2>Supplementary tilemaps (optional)</h2>
      <p>
        Tileset pages often contain more than 1 tilemap, you can provide these
        here (multiple files supported). If you're not certain what the
        supplementary tilemaps are, then leave this blank and load your main
        tilemap. The names of the supplementary tilemaps will appear in the
        input field at the bottom of this page, which you can use to look them
        up. Format: /images/tilemap_[GAMESTYLE]_[NAME].png
      </p>
      <div class="input-group">
        <input
          type="file"
          id="supplementaryInput"
          accept=".png"
          multiple
          onchange="document.getElementById(`reload`).disabled = false"
        />
      </div>

      <div style="display: flex; justify-content: space-between">
        <button id="reload" onclick="loadPrevious()">
          Load previous inputs
        </button>
        <button style="background-color: #3498db" onclick="openDocs(this)">
          Docs
        </button>
        <button id="submit" onclick="visualize()">Visualize</button>
      </div>

      <div id="docs" style="display: none">
        <h2>Documentation</h2>
        <h3>Formats</h3>
        Objects/single-tiles in the layouts file have several values separated
        by underscores. They are as follows for objects:<br />
        <span style="background-color: rgb(132, 255, 0)"
          >objects:
          o(obj)_objID_frame_extraValues_offsetX_offsetY_mirrorMode_angle_containedObjID</span
        ><br />
        And for tiles:<br />
        <span style="background-color: rgb(132, 255, 0)"
          >t(tile)_tilemap_tileID_offsetX_offsetY_tileStateID</span
        ><br />
        And tile structures:<br />
        <span style="background-color: rgb(132, 255, 0)"
          >s(structure)_tilemapName_rowLength_tileData_structureOffsetX_structureOffsetY_gridOffsetX_gridOffsetY</span
        >
        <br />
        For values O, S & T you might have to swap to a different tilemap. Check
        the resulting array in the output below the canvas for the name of this
        tilemap. It will most likely be named tilemap_1_[name] or
        tilemap_2_[name].
        <br />
        <h3>Canvas values</h3>
        X - Empty space (no tile)<br />
        # - Empty space (scrollbar is located here)<br />
        numbers - ID of the tile<br />
        o/s/t - Indicates an object, structure or tile belonging in this
        position<br />
        o/s/t + number - ID of the tile, which is part of an object/structure<br />
        <h3>Special characters</h3>
        * = shorthand for the base tilemap, only use this value for id's start
        with o/s/t. The base tilemap is defined in the
        <b>/layouts/object storage</b> file for your tileset, so make sure it is
        set to the correct one. eg. the SMAS sewer tileset has the
        tilemapBaseName value set to 1_Sewer.<br />
        $ = get current palette ID (empty if default palette, only applies to
        non-base tilemaps such as "SewerA" or "AirshipB")<br />
        # = same as the star (*), but this is used for additives to the tilemap
        in the editor. Eg. "t_SewerA_0" is written as "t_#A$_0". The # stands
        for "Sewer" in this context, and the dollar sign grabs the currently
        selected palette to let the game know this tile also has different
        palettes.
        <h3>Multi tile structures</h3>
        Multi tile structures start with an "s" as described under the formats
        header, they contain multiple tile ID's per entry. When editing one,
        make sure to use a reference to a different tilemap. The most important
        values are the tiledata and rowlength since those decide the size and
        components of the structure. The offset is mainly used in the editor to
        make the structure display properly, preferably reuse values for the
        same structure types.<br />
        <h3>Creating a new entry</h3>
        When creating a new entry, make sure to first load a different tilemap
        and its JSON id as a reference. After that you can change the values in
        the output array to your liking and revisualize to preview with the new
        tilemap. Once you're happy with the result, you can generate a new JSON
        file to replace the one in the game files. You won't have to replace any
        images since SMC automatically assigns the correct images to the tile
        ID's.
        <h3>Exporting</h3>
        You can export either by editing the entry you inputed (the JSON index)
        or by adding a new entry. If you are adding a new entry, use the pink
        button on the bottom of the page after loading the canvas. Either option
        will give you a new JSON to replace the old one with.
      </div>

      <div id="output" style="display: none">
        <h2 style="text-align: center" id="refHdr">
          Reference (click to mark tiles)
        </h2>
        <div
          style="
            display: grid;
            grid-template-columns: 1fr;
            justify-items: center;
            align-items: center;
          "
          id="canvas-container"
        ></div>
        <br />
        <h2 style="text-align: center">Tileset page preview</h2>
        <div style="display: flex; justify-content: center; gap: 8px">
          <button
            style="background-color: green"
            onclick="toggleMarkings(this)"
            title="Toggles symbols on the canvas"
          >
            Toggle markings
          </button>
          <button
            onclick="changeMarkingColour(this)"
            title="Cycle between marking colours"
            style="background-color: lime; color: black"
          >
            Change marking colour
          </button>
          <button
            style="background-color: red"
            onclick="toggleAutoUpdate(this)"
          >
            Auto update
          </button>
        </div>
        <canvas id="canvas"></canvas>

        <textarea id="jsonValues"></textarea>
        <input
          id="uniqueWords"
          type="text"
          placeholder="This tilemap has no tiles from other tilemaps."
          readonly
          title="These are the supplementary tilemaps belonging to the JSON index (editor page), outside of the main one."
        />
        <div style="display: flex; justify-content: center; gap: 8px">
          <button id="save" onclick="saveTextarea(this)">
            Save textarea & reference</button
          ><button id="load" onclick="loadTextarea(this)">
            Load textarea & reference
          </button>
          <button id="saveEdited" onclick="exportJson(false)">
            Export JSON file with edited page entry
          </button>
          <button id="saveNew" onclick="exportJson(true)">
            Export JSON file with new page entry
          </button>
        </div>
      </div>
    </div>

    <script>
      let showMarkings = true;
      let loadedImage = null;
      let loadedSupplementaryImages = [];
      let loadedJsonData = null;
      let loadedIndex = null;
      let currentColour = "lime";
      let specialColour = "blue";
      let tilemapNames = [];
      let referenceArray = null;
      let autoUpdate = false;
      let jsonFilename = "";
      let referenceCanvasArrays = [];
      let prevIndex = null;

      // open/close docs
      const openDocs = (e) => {
        const docs = document.getElementById("docs");
        const isOpen = docs.style.display === "block";
        docs.style.display = isOpen ? "none" : "block";
        e.style.backgroundColor = isOpen ? "#3498db" : "#8845db";
        if (!isOpen)
          window.scrollTo({
            top: docs.getBoundingClientRect().top + window.pageYOffset,
            behavior: "smooth",
          });
      };
      // Open IndexedDB
      const openDB = () => {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open("TileLayoutDB", 1);

          request.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains("tiles")) {
              // Create the object store only if it doesn't already exist
              const store = db.createObjectStore("tiles", {
                keyPath: "customKey",
                autoIncrement: false,
              });
            }
          };

          request.onsuccess = (e) => resolve(e.target.result);
          request.onerror = (e) => reject(e.target.error);
        });
      };

      // Store data in IndexedDB
      const storeData = (
        jsonFile,
        spriteFile,
        indexValue,
        supplementaryImages
      ) => {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open("TileLayoutDB", 1);

          request.onupgradeneeded = function (event) {
            const db = event.target.result;
            if (!db.objectStoreNames.contains("tiles")) {
              const store = db.createObjectStore("tiles", {
                keyPath: "customKey",
                autoIncrement: false,
              });
            }
          };

          request.onerror = function () {
            reject("Failed to open IndexedDB.");
          };

          request.onsuccess = async (event) => {
            const db = event.target.result;
            const tx = db.transaction("tiles", "readwrite");
            const store = tx.objectStore("tiles");

            const record = {
              json: jsonFile,
              sprite: spriteFile,
              extraTilemaps: supplementaryImages,
              customKey: `index_1`,
              index: indexValue,
            };
            await store.clear();
            const addRequest = store.put(record);

            // Resolves the returned Promise with the string "Data successfully stored in IndexedDB."
            addRequest.onsuccess = function () {
              resolve("Data successfully stored in IndexedDB.");
            };

            addRequest.onerror = function () {
              reject("Failed to store data in IndexedDB.");
            };

            tx.oncomplete = function () {
              db.close();
            };
          };
        });
      };

      // Retrieve data from IndexedDB
      const loadPrevious = async () => {
        const db = await openDB();
        const tx = db.transaction("tiles", "readonly");
        const store = tx.objectStore("tiles");

        return new Promise((resolve, reject) => {
          // Get the record with id = 1
          const request = store.get("index_1"); // Get the first (and only) record
          document.getElementById("reload").disabled = true;

          // Handle success
          request.onsuccess = () => {
            const record = request.result;
            if (record) {
              const jsonFile = new File([record.json], record.json.name, {
                type: "application/json",
              });
              const spriteFile = new File([record.sprite], record.sprite.name, {
                type: "image/png",
              });
              const supplementaryImages =
                Array.from(record.extraTilemaps) || [];
              // Set the file inputs to the saved data
              document.getElementById("jsonInput").files = new FileListItem([
                jsonFile,
              ]);
              document.getElementById("spriteInput").files = new FileListItem([
                spriteFile,
              ]);
              const supplementaryFileList = new DataTransfer();
              supplementaryImages.forEach((file) =>
                supplementaryFileList?.items?.add(file)
              );
              document.getElementById("supplementaryInput").files =
                supplementaryFileList.files;
              document.getElementById("indexInput").value = record.index;
              showNotification("Previous data loaded.");

              resolve(visualize()); // Resolve the promise after successfully loading the record
            } else {
              showNotification("No previous data found.");
              reject(new Error("No record found"));
            }
          };

          // Handle error
          request.onerror = (e) => {
            reject(e.target.error); // Reject if there's an error fetching the record
          };
        });
      };

      // Helper function to simulate FileList (for loading previous files)
      function FileListItem(files) {
        const b = new ClipboardEvent("").clipboardData || new DataTransfer();
        files.forEach((file) => b.items.add(file));
        return b.files;
      }

      // Function to visualize
      const visualize = async () => {
        // Get input values
        const jsonFile = document.getElementById("jsonInput").files[0];
        const indexValue = parseInt(
          document.getElementById("indexInput").value,
          10
        );
        const spriteFile = document.getElementById("spriteInput").files[0];
        const supplementaryImages =
          document.getElementById("supplementaryInput").files;

        // Check conditions
        if (!jsonFile || !spriteFile) {
          showNotification(
            "Please provide both a JSON file and a sprite sheet."
          );
          return;
        }

        // Check if index is valid
        if (indexValue < 0)
          return showNotification("Index must be a minimum of 0.");
        // Read JSON
        const reader = new FileReader();
        reader.onload = async function (event) {
          const jsonData = JSON.parse(event.target.result);

          // Validate JSON size
          if (jsonData.size && parseInt(jsonData.size[2]) <= indexValue) {
            showNotification(
              `The maximum index you can input is ${
                parseInt(jsonData.size[2]) - 1
              }.
            `
            );
            return;
          }

          // Read sprite sheet
          const spriteReader = new FileReader();
          const supplementaryReader = new FileReader();

          // load main tilemap
          spriteReader.onload = async function (event) {
            const img = new Image();
            img.onload = async function () {
              // Validate sprite sheet dimensions
              if (img.width % 16 !== 0 || img.height % 16 !== 0) {
                showNotification(
                  "Sprite sheet dimensions must be multiples of 16."
                );
                return;
              }

              // Store main image and related data
              loadedImage = img;
              loadedJsonData = jsonData;
              loadedIndex = indexValue;

              // Load supplementary images sequentially
              for (const image of supplementaryImages) {
                await loadSupplementaryImage(image);
              }

              await storeData(
                jsonFile,
                spriteFile,
                indexValue,
                supplementaryImages
              );

              const canvases = document.querySelectorAll("canvas");
              if (canvases.length > 0)
                canvases.forEach((canvas) => {
                  if (canvas.id !== "canvas") {
                    canvas.remove();
                  }
                });
              // Display on canvas
              generateReference(null, 0);
              for (let i = 0; i < supplementaryImages.length; i++) {
                generateReference(null, i + 1);
              }
              if (supplementaryImages.length > 0)
                document.getElementById("refHdr").textContent =
                  "References (click to mark tiles)";
              else
                document.getElementById("refHdr").textContent =
                  "Reference (click to mark tiles)";

              loadElements(true);
            };

            // Set the sprite sheet data URL
            img.src = event.target.result;
            jsonFilename = jsonFile.name;
          };

          // Start loading the main sprite map
          loadedSupplementaryImages = [];
          tilemapNames = [];
          spriteReader.readAsDataURL(spriteFile);
        };
        reader.readAsText(jsonFile); // Read JSON file as text
      };

      // Function to read supplementary images as a Promise
      const loadSupplementaryImage = (image) => {
        return new Promise((resolve, reject) => {
          const supplementaryReader = new FileReader();
          supplementaryReader.onload = function (event) {
            const supImg = new Image();
            supImg.onload = function () {
              // Validate sprite sheet dimensions
              if (supImg.width % 16 !== 0 || supImg.height % 16 !== 0) {
                showNotification(
                  `Tilemap dimensions of ${supImg.src} aren't multiples of 16.`
                );
                reject(new Error("Invalid tilemap dimensions."));
                return;
              }
              loadedSupplementaryImages.push(supImg);
              tilemapNames.push(
                image.name.split("_")[2].split(".")[0].toLowerCase()
              );
              resolve();
            };
            supImg.src = event.target.result;
          };
          supplementaryReader.onerror = reject;
          supplementaryReader.readAsDataURL(image);
        });
      };

      const extractUniqueWords = (nestedArray) => {
        const uniqueWords = new Set();

        nestedArray.flat().forEach((item) => {
          if (typeof item === "string") {
            // Use regex to match words between underscores
            const matches = item.match(/(?<=_)[a-zA-Z0-9]+(?=_)/g);
            if (matches) {
              matches.forEach((word) => {
                // Only add words that contain letters (to avoid adding numbers alone)
                if (/[a-zA-Z]/.test(word)) {
                  uniqueWords.add(word);
                }
              });
            }
          }
        });

        return Array.from(uniqueWords);
      };
      // Function to load saved files from IndexedDB
      const loadElements = (scroll) => {
        try {
          const output = document.getElementById("output");
          const reference = document.getElementById("reference");
          const jsonOutput = document.getElementById("jsonValues");
          const uniqueWordsOutput = document.getElementById("uniqueWords");
          const ctx = canvas.getContext("2d");
          const placementArray = loadedJsonData.data;

          ctx.imageSmoothingEnabled = false;
          ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

          const columns = loadedJsonData.size[0];
          const rows = loadedJsonData.size[1];

          // Initialize a 2D array with `false` values indicating empty cells
          referenceArray = Array.from({ length: rows }, () =>
            Array.from({ length: columns }, () => false)
          );
          const resultArray =
            jsonOutput.value && prevIndex === loadedIndex
              ? JSON.parse(jsonOutput.value)
              : [];

          // Iterate through rows first
          if (resultArray.length === 0) {
            for (
              let rowIndex = 0;
              rowIndex < placementArray[0].length;
              rowIndex++
            ) {
              const processedRow = [];
              // Iterate through columns for each row
              for (
                let colIndex = 0;
                colIndex < placementArray.length;
                colIndex++
              ) {
                const col = placementArray[colIndex];
                // Extract the value at the current rowIndex from each column
                processedRow.push(col[rowIndex][loadedIndex]);
              }

              // Push the processed row into resultArray
              resultArray.push(processedRow);
            }
          }

          prevIndex = loadedIndex;

          const uniqueWords = extractUniqueWords(resultArray);
          uniqueWordsOutput.value = uniqueWords.join(", ");

          canvas.width = resultArray[0].length * 18;
          canvas.height = resultArray.length * 18;
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = currentColour;
          const offsetX = 9;
          const offsetY = 10;

          // Iterate over resultArray to map tiles on the canvas
          resultArray.forEach((row, rowIndex) => {
            row.forEach((tileString, colIndex) => {
              // Calculate the destination position for the tile on the canvas
              const destX = colIndex * 18;
              const destY = rowIndex * 18;
              let imageToUse = loadedImage;

              // Extract the numerical ID if the tileString is not empty
              let [tileIndex, draw] = extractID(tileString, colIndex);

              if (draw === "X") return;
              if (
                draw &&
                ["t", "s", "o"].includes(draw[0]) &&
                tileIndex !== null
              ) {
                const split = tileString.split("_");
                const tilemapRef = split[1].toLowerCase();
                const imageIndex = tilemapNames.indexOf(tilemapRef);

                ctx.fillStyle = specialColour;
                if (imageIndex !== -1)
                  imageToUse = loadedSupplementaryImages[imageIndex];
              }

              // Calculate the source position for the tile in the image
              const srcX = (tileIndex % (loadedImage.width / 16)) * 16; // column in the sprite sheet
              const srcY =
                Math.floor(tileIndex / (loadedImage.width / 16)) * 16; // row in the sprite sheet

              if (draw !== null && draw !== "multi" && tileIndex === null) {
                if (referenceArray[rowIndex][colIndex]) return;
                if (draw === "#") ctx.fillStyle = "red";

                if (showMarkings)
                  ctx.fillText(draw, destX + offsetX, destY + offsetY);
                ctx.fillStyle = currentColour;
                referenceArray[rowIndex][colIndex] = true;
                return;
              }
              // multi tile structures
              if (draw === "multi") {
                return drawSpecialEntry(tileString, ctx, destX, destY);
                // for non multi tile structures/objects
              }
              ctx.drawImage(
                imageToUse,
                srcX,
                srcY, // Source coordinates on the sprite sheet
                16,
                16, // Width and height of the tile
                destX + 1,
                destY + 1, // Destination coordinates on the canvas
                16,
                16 // Width and height on the canvas
              );

              // Draw the numerical ID on the canvas
              if (showMarkings && !referenceArray[rowIndex][colIndex]) {
                if (draw) ctx.fillStyle = specialColour;
                ctx.fillText(
                  draw ? draw : tileIndex,
                  destX + offsetX,
                  destY + offsetY
                );
                ctx.fillStyle = currentColour;
                referenceArray[rowIndex][colIndex] = true;
              }
            });
          });
          ctx.fillStyle = "red";

          if (showMarkings)
            referenceArray.forEach((row, rowIndex) => {
              row.forEach((value, colIndex) => {
                if (value === false) {
                  const destX = colIndex * 18;
                  const destY = rowIndex * 18;
                  ctx.fillText("X", destX + offsetX, destY + offsetY);
                }
              });
            });

          if (!jsonOutput.textContent)
            jsonOutput.textContent = JSON.stringify(resultArray).replace(
              /\],/g,
              "],\n"
            );
          document.getElementById("reload").disabled = true;
          output.style.display = "block";
          if (scroll) {
            const canvasElement = document.getElementById("canvas");
            const topPos =
              canvasElement.getBoundingClientRect().top +
              window.pageYOffset -
              window.innerHeight * 0.44 +
              canvasElement.offsetHeight / 2;
            window.scrollTo({
              top: topPos,
              behavior: "smooth",
            });
          }
        } catch (error) {
          console.error(error);
          showNotification("Error: " + error.message);
        }
      };

      const drawSpecialEntry = (input, ctx, destX, destY) => {
        // Split the string by underscores
        const parts = input.split("_");
        // Extract values into separate constants
        const tilemapName = parts[1].toLowerCase();
        const tilemapIndex = tilemapNames.indexOf(tilemapName);
        const rowLength = parseInt(parts[2]);
        const tileData = parts[3].split(",");
        const structureOffsetX = 1 + parseInt(parts[4] || 0);
        const structureOffsetY = 1 + parseInt(parts[5] || 0);

        let curX = destX;
        let curY = destY;
        let entryX = curX / 18;
        let entryY = curY / 18;
        let curRowIndex = 1;

        const img =
          tilemapIndex !== -1
            ? loadedSupplementaryImages[tilemapIndex]
            : tilemapName === "*"
            ? loadedImage
            : null;

        if (img === null) return;

        const nextEntry = (val) => {
          if (curRowIndex === rowLength) {
            curY += val;
            entryY += 1;
            curRowIndex = 1;
            curX = destX;
            entryX = curX / 18;
          } else {
            curX += val;
            entryX += 1;
            curRowIndex++;
          }
        };

        tileData.forEach((tileIndex) => {
          if (tileIndex === null || isNaN(tileIndex)) return; // Skip invalid tile indices
          const srcX = (tileIndex % (img.width / 16)) * 16; // column in the sprite sheet
          const srcY = Math.floor(tileIndex / (img.width / 16)) * 16; // row in the sprite sheet
          // Draw the tile onto the canvas
          ctx.drawImage(
            img,
            srcX,
            srcY,
            16,
            16,
            curX + structureOffsetX,
            curY + structureOffsetY,
            16,
            16
          );
          // increment
          nextEntry(16);
        });

        curX = destX;
        curY = destY;
        entryX = curX / 18;
        entryY = curY / 18;

        if (showMarkings) {
          tileData.forEach((tileIndex) => {
            // Draw the numerical ID on the canvas
            if (!referenceArray[entryY][entryX]) {
              ctx.fillStyle = specialColour;
              ctx.strokeStyle = specialColour;
              ctx.save();
              ctx.translate(curX + 9, curY + 10);
              ctx.rotate(-Math.PI / 4);
              ctx.fillText(input[0] + tileIndex, 0, 0);
              ctx.restore();
              ctx.fillStyle = currentColour;
              referenceArray[entryY][entryX] = true;
            }
            nextEntry(18);
          });
          ctx.strokeRect(
            destX,
            destY,
            18 * rowLength,
            18 * (tileData.length / rowLength)
          );
        }
      };

      // Iterate over resultArray to map tiles on the canvas
      const extractID = (str, colIndex) => {
        // ignore tilestrings that are empty
        if (str === "") return [null, colIndex === 17 ? "#" : "X"];

        // if its a number, return directly, unless this is a supplementary tilemap
        if (typeof str === "number") return [str, null];

        if (["o", "s", "t"].includes(str[0])) {
          // use another tilemap not belonging to the JSON index
          const split = str.split("_");
          const tilemapRef = split[1].toLowerCase();
          if (tilemapNames.includes(tilemapRef)) {
            if (split.length > 3) return [null, "multi"];
            const number = parseInt(split[2], 10);
            return [number, str[0] + number];
          }

          // use current tilemap
          if (/^[ost]_\*_/.test(str)) return [null, "multi"];

          // other spritesheet
          return [null, str[0]];
        }
        return [null, "X"];
      };

      const toggleMarkings = (e) => {
        const styles = e.style.backgroundColor === "green" ? "red" : "green";
        e.style.backgroundColor = styles;
        e.disabled = true;
        showMarkings = !showMarkings;
        loadElements(false);
        setTimeout(() => {
          e.disabled = false;
        }, 500);
      };

      const changeMarkingColour = (e) => {
        const colour = e.style.backgroundColor;
        switch (colour) {
          case "lime":
            currentColour = "purple";
            specialColour = "chartreuse";
            e.style.color = "white";
            break;
          case "purple":
            currentColour = "cyan";
            e.style.color = "black";
            specialColour = "black";
            break;
          case "cyan":
            currentColour = "yellow";
            specialColour = "pink";
            break;
          case "yellow":
            currentColour = "black";
            e.style.color = "white";
            specialColour = "darkgreen";
            break;
          case "black":
            currentColour = "orange";
            specialColour = "brown";
            break;
          default:
            currentColour = "lime";
            e.style.color = "black";
            specialColour = "blue";
            break;
        }
        e.style.backgroundColor = currentColour;
        showMarkings = true;
        generateReference(null, 0);
        for (let i = 0; i < loadedSupplementaryImages.length; i++) {
          generateReference(null, i + 1);
        }
        loadElements(false);
      };

      // Container element for canvases
      const container = document.querySelector("div");

      // Function to generate a new reference canvas
      const generateReference = (e, index) => {
        const container = document.getElementById("canvas-container");
        const canvasId = `reference-${index}`;
        let image;
        let reference = e?.target
          ? e.target
          : document.getElementById(canvasId);
        if (e?.target?.id) {
          const targetIndex = parseInt(e.target.id.split("-")[1]);
          image =
            targetIndex === 0
              ? loadedImage
              : loadedSupplementaryImages[targetIndex - 1];
        } else {
          image =
            index === 0 ? loadedImage : loadedSupplementaryImages[index - 1];
        }

        if (!reference) {
          // Create and append a new canvas if it doesn't exist
          reference = document.createElement("canvas");
          reference.id = canvasId;
          reference.style.margin = "10px";
          container.appendChild(reference);
        }

        const ctx = reference.getContext("2d");
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, reference.width, reference.height);
        reference.width = image.width * 2;
        reference.height = image.height * 2;
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = currentColour;
        ctx.strokeStyle = currentColour;
        const val = 32;
        const halfVal = val / 2;

        // Initialize referenceCanvasArrays for the canvas
        if (!e && !referenceCanvasArrays[index]) {
          referenceCanvasArrays[index] = Array.from(
            { length: reference.height / val },
            () => Array.from({ length: reference.width / val }, () => false)
          );
        }

        if (e && e.type === "click") {
          const cursorX = e.offsetX;
          const cursorY = e.offsetY;
          const x = Math.floor(cursorX / val);
          const y = Math.floor(cursorY / val);
          referenceCanvasArrays[index][y][x] =
            !referenceCanvasArrays[index][y][x];
        }

        ctx.drawImage(image, 0, 0, reference.width, reference.height);

        let number = 0;
        for (let y = 0; y < reference.height; y += val) {
          for (let x = 0; x < reference.width; x += val) {
            if (referenceCanvasArrays[index][y / val][x / val]) {
              ctx.fillStyle = "rgba(255,0,0,0.67)";
              ctx.fillRect(x, y, val, val);
              ctx.fillStyle = "black";
            } else {
              ctx.strokeRect(x, y, val, val);
            }
            ctx.fillText(number, x + halfVal, y + halfVal);
            number++;
            ctx.fillStyle = currentColour;
          }
        }

        if (!reference.eventListenerCount) {
          reference.addEventListener("click", (event) =>
            generateReference(event, index)
          );
          reference.eventListenerCount = true; // Custom flag to prevent multiple listeners
        }
      };

      const toggleAutoUpdate = (e) => {
        const inputHandler = () => loadElements(false);
        e.style.backgroundColor =
          e.style.backgroundColor === "red" ? "green" : "red";
        e.disabled = true;
        loadElements(true);
        autoUpdate = !autoUpdate;
        setTimeout(() => {
          e.disabled = false;
        }, 500);
        if (autoUpdate) {
          showNotification(
            "Editing the array in the text area will now auto update the canvas."
          );
          return document
            .getElementById("jsonValues")
            .addEventListener("input", inputHandler);
        }
        showNotification("Disabled auto updating for all elements.");
        return document
          .getElementById("jsonValues")
          .removeEventListener("input", inputHandler);
      };

      const showNotification = (message) => {
        // Check if there's already an existing notification
        const existingNotification = document.querySelector(".notification");

        // If there's an existing notification, remove it immediately
        if (existingNotification) {
          existingNotification.remove();
        }
        // Create the notification element
        const notification = document.createElement("div");
        notification.className = "notification";
        notification.textContent = message;

        // Append the notification to the body
        document.body.appendChild(notification);

        // Trigger the animation (fade in)
        setTimeout(() => {
          notification.style.opacity = "1";
        }, 100);

        // Hide the notification after 2 seconds
        setTimeout(() => {
          notification.style.opacity = "0";
          // Remove the notification element from the DOM after fading out
          setTimeout(() => {
            notification.remove();
          }, 500);
        }, 3000);
      };

      const saveTextarea = (e) => {
        const textarea = document.getElementById("jsonValues");
        const content = textarea.value;
        localStorage.setItem("jsonValues", content);
        localStorage.setItem(
          "referenceCanvasArrays",
          JSON.stringify(referenceCanvasArrays)
        );
        showNotification("Saved tileset page array to local storage!");
      };

      const loadTextarea = (e) => {
        const textarea = document.getElementById("jsonValues");
        const content = localStorage.getItem("jsonValues");
        referenceCanvasArrays = JSON.parse(
          localStorage.getItem("referenceCanvasArrays")
        );
        if (!content)
          return showNotification(
            "You haven't saved anything in your local storage!"
          );
        textarea.value = content;
        generateReference(null, 0);
        for (let i = 0; i < loadedSupplementaryImages.length; i++) {
          generateReference(null, i + 1);
        }
        loadElements(false);
        showNotification("Loaded tileset page array from local storage!");
      };

      const exportJson = (newEntry) => {
        const array = JSON.parse(document.getElementById("jsonValues").value);
        let jsonArray = JSON.parse(JSON.stringify(loadedJsonData.data));
        const cols = loadedJsonData.size[0];
        const rows = loadedJsonData.size[1];

        // Iterate through each row of resultArray
        for (let rowIndex = 0; rowIndex < rows; rowIndex++) {
          const row = array[rowIndex];

          // Iterate through each column of the current row
          for (let colIndex = 0; colIndex < cols; colIndex++) {
            const value = row?.[colIndex];
            // add the value to the JSON, or edit it
            if (newEntry) jsonArray[colIndex][rowIndex].push(value);
            else jsonArray[colIndex][rowIndex][loadedIndex] = value;
          }
        }
        const jsonObject = {
          c2array: true,
          size: loadedJsonData.size,
          data: jsonArray,
        };
        if (newEntry) jsonObject.size[2] += 1;
        const jsonFile = JSON.stringify(jsonObject);
        const blob = new Blob([jsonFile], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = jsonFilename;
        a.click();
        URL.revokeObjectURL(url);
      };
    </script>
  </body>
</html>
